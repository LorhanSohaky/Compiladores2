+++++
type: monography
title: "Teste 0"
author: "Usuário 0"
date: 26/11/2019
header-includes: "\usepackage{listings}"
+++++
*****
# Introdução
A detecção de arestas e vértices de corte está presente em diversos problemas do cotidiano, mesmo que de forma imperceptível, são problemas como, por exemplo, detectar pontos de vulnerabilidade de uma rede de computadores, o impacto da perda de um dos pontos de distribuição de um produto / serviço e pontos frágeis de comunicação numa organização hierárquica. Verificar arestas e vértices de corte é importante para estipular a topologia do grafo ao remover uma aresta.

Teoria dos Grafos é um ramo da matemática que estuda a relação entre objetos de um determinado conjunto. Em que * V * representa o conjunto de vértices e * A * o conjunto de arestas do grafo * G *. Representado por:

* G=(V,A) *
* A={(x,y) | x, y pertence V} *

Uma aresta * a pertence A * de corte se * G - a * é desconexo, ou seja, a remoção de uma aresta-de-corte desconecta o grafo. Um vértice * v * é  considerado um vértice de corte se e somente se * v * tem um filho * t * tal que não existe aresta ligando qualquer descendente de * t * a um ancestral de * v * [@cormen].

Uma árvore é formada por um conjunto de elementos chamados nós. Toda a árvore possui um elemento chamado raiz, que está ligado a outros elementos chamados filhos ou ramos. Estes ramos podem estar ligados a outros elementos e assim sucessivamente. O elemento que não possui filhos é denominado como nó folha. A profundidade de um nó é a distância deste nó até a raiz da árvore. Um conjunto de nós com a mesma profundidade é chamado nível.

O algoritmo de busca em largura (* Breadth-First Search - BFS * ) começa por um vértice raiz qualquer, e explora todos vértices que estão no mesmo nível, então avança para os vértices do nível seguinte e assim sucessivamente até que não haja mais vértices inexplorados, resultando em uma árvore com a ordem em que os vértices foram sendo explorados. Em resumo, a cada novo nível descoberto, todos os vértices daquele nível devem ser visitados antes de prosseguir para o próximo nível.

O algoritmo de busca em profundidade (* Depth-First Search - DFS *) começa num vértice raiz qualquer, e explora um vértice filho tanto quanto possível - até chegar num nó folha; quando não for mais possível é feito o retrocesso para o nó do nível superior e um outro vértice filho é explorado e, assim por diante, até que não haja mais vértices não descobertos, resultando em uma árvore com a ordem em que os vértices foram descobertos. Em resumo, esse método imita a exploração de um labirinto, tentando ir o mais longe possível e quando não houver mais caminho, volta para o ponto onde teve de escolher um dos caminhos.

Devido ao funcionamento distinto do * DFS * e do * BFS *, as árvores resultantes podem ser diferentes e é nessa diferença em que este artigo explora uma maneira de trabalhar com as árvores para encontrar as arestas e vértices de corte. A \autoref{fig:comparacaoBFSeDFS} evidencia a diferença entre as árvores geradas usando *BFS* e *DFS*.

Na seção Desenvolvimento é apresentada solução que foi desenvolvida,  como foi verificada a eficácia do algoritmo e a linguagem escolhida para desenvolver; na \autoref{sec:trabalhos} são apresentados os trabalhos providos da revisão sistemática e que estão relacionados com este artigo e na \autoref{sec:consideracoes} são apresentadas as principais dificuldades e limitações da solução.

# Desenvolvimento
O algoritmo pode ser explicado em pseudo-código. Para solucionar o problema e poder testar com grafos maiores o algoritmo foi implementado na linguagem de programação Python, esta linguagem foi escolhida para tirar proveito de algumas bibliotecas já prontas para lidar com grafos, como por exemplo, a biblioteca [NetworkX](https://networkx.github.io/ ).

Foram gerados alguns grafos para testar o algoritmo de modo manual (no papel). Após testar o algoritmo em um conjunto de grafos, mais simples que podem ser facilmente desenhados no papel, o algoritmo foi submetido a um conjunto diferente de grafos para avaliar melhor sua eficácia. Os grafos escolhidos foram retirados do repositório de \citeonline{nr} e, são eles [aves-weaver-social-11](http://networkrepository.com/aves-weaver-social-11.php), [fly-drosophila-medulla-1](http://networkrepository.com/bn-fly-drosophila-medulla-1.php), [whois](http://networkrepository.com/tech-WHOIS.php) e [webbase-2001](http://networkrepository.com/web-webbase-2001.php).

## Algoritmo
O algoritmo, se baseia na diferença entre as árvores geradas pelo * DFS * e * BFS *. Visto que um vértice * v * é considerado um vértice de corte se e somente se * v * tem um filho * t * tal que não existe aresta ligando qualquer descendente de * t * a um ancestral de * v *, se na busca em largura aparecer um vértice filho de * t * ligado a um ancestral de * v *, isso caracteriza que * v * não é um vértice de corte e, este filho de * t * irá aparecer na árvore do * BFS * devido a características de buscar por nível.

O algoritmo base em pseudo-código fica da seguinte maneira:

1. Gerar a árvore * BFS * e * DFS * a partir de um mesmo vértice * a *, que será o primeiro ancestral em comum;
2. Para cada vértice * v pertence DFS * verificar se * não existe (a,v) * na * BFS *,  nesse caso o vértice * w *, que é o ancestral de * v * na * DFS * passará a ser o novo ancestral em comum, a aresta * (w,v) * passa a ser de corte e os vértices * w * e * v * são marcados como de corte.
3. Todo nó que for folha em ambas as árvores e tiver o mesmo ancestral em comum * z *, este vértice * z * é considerado vértice de corte.

Algumas modificações foram necessárias pra trazer melhor corretude ao algoritmo, no \autoref{passo2}, antes de considerar * v * como de corte é verificado se este vértice é um nó folha, caso não seja, então pode ser considerado como de corte. Além disso, as arestas e vértices podem ser marcados como de corte mais de uma vez, então é necessário remover a repetição. O \autoref{code:meu_codigo} é a implementação do algoritmo com as modificações citadas e uma verificação se o ancestral comum é diferente do vértice que está sendo analisado, isso serve apenas para melhorar a eficiência.

Implementação do algoritmo em Python.
```python
import networkx as nx


def algoritmo(G, source):
	arestas_corte = []
	vertices_corte = []
	dfs_tree = nx.dfs_tree(G, source)
	bfs_tree = nx.bfs_tree(G, source)

	ancestral_comum = source
	for vertice in list(dfs_tree.nodes):
		if ancestral_comum != vertice and not (ancestral_comum,
				vertice) in list(bfs_tree.edges):
			predecessor = dict(nx.bfs_predecessors(dfs_tree,
							   source))[vertice]
			ancestral_comum = vertice

			arestas_corte.append((predecessor, vertice))
			vertices_corte.append(predecessor)
			if not (dfs_tree.out_degree(vertice) == 0
					and dfs_tree.in_degree(vertice) == 1
					and bfs_tree.out_degree(vertice) == 0
					and bfs_tree.in_degree(vertice) == 1
					and dict(nx.bfs_predecessors(dfs_tree,
					source))[vertice]
					== dict(nx.bfs_predecessors(bfs_tree,
					source))[vertice]):
				vertices_corte.append(vertice)
		elif dfs_tree.out_degree(vertice) == 0 \
			and dfs_tree.in_degree(vertice) == 1 \
			and bfs_tree.out_degree(vertice) == 0 \
			and bfs_tree.in_degree(vertice) == 1 \
			and dict(nx.bfs_predecessors(dfs_tree, source))[vertice] \
			== dict(nx.bfs_predecessors(bfs_tree, source))[vertice]:
			predecessor = dict(nx.bfs_predecessors(dfs_tree,
							   source))[vertice]
			vertices_corte.append(predecessor)

	return (vertices_corte, arestas_corte)
```

Para verificar a eficácia do algoritmo proposto, ele foi comparado com as funções [articulation\_points](https://networkx.github.io/documentation/networkx-1.10/reference/generated/networkx.algorithms.components.biconnected.articulation_points.html) e [bridges](https://networkx.github.io/documentation/latest/reference/algorithms/generated/networkx.algorithms.bridges.bridges.html) da biblioteca NetworkX.

O algoritmo proposto foi submetido ao caso de teste da \autoref{fig:caso-teste1} e a execução é demonstrada pela \autoref{tab:caso1}. A \autoref{fig:caso-teste2} mostra o segundo grafo de teste e sua execução na \autoref{tab:caso2}, é importante ressaltar que as arestas e vértices de corte em ** negrito ** são os falsos positivos.

# Trabalhos relacionados
Os trabalhos foram selecionados mediante a uma revisão sistemática, afim de não enviesar a pesquisa. Todos os trabalhos têm como objetivo encontrar arestas e vértices de corte de um grafo e, é isto o que possuem em comum, mas cada um o faz com estratégias diferentes.

No artigo de [@italiano2012] são apresentados algoritmos de tempo linear para computar todas as arestas de corte e todos os vértices de corte de grafos direcionados explorando uma conexão entre vértices e arestas de corte.

Para encontrar as arestas de corte é escolhido um vértice qualquer para inicial, em seguida é determinado o conjunto de dominadores (vértices em que todos os caminhos para qualquer vértices passam por eles) de arestas, calculado o grafo reverso e determinado o conjunto de dominadores de arestas deste grafo reverso, por fim, a saída é a união do conjunto de dominadores de arestas e com a inversão das arestas do conjunto de dominadores de arestas do grafo reverso.

Para encontrar os pontos de articulação (vértices de corte), é escolhido arbitrariamente um vértice para testar se ele é um ponto de articulação, se for, a saída é este próprio vértice; é calculado o conjunto de dominadores não triviais de * G(s) *, depois é determinado o grafo reverso e calculado o conjunto de dominadores não triviais neste grafo reverso e, por fim, a saída é a união dos dominadores de * G(s) *  com os dominadores do * G elevado a R(s) *.

No artigo de [@ibarra1993] é evidenciado que os pontos de articulação (vértice de corte) e pontes (aresta de corte) do grafo de permutação podem ser encontrados em * O (log n) *, diferentemente do tradicional algoritmo de busca em profundidade que demora * O (log n) * com * O (n elevado 2/\log n) * processadores. Os algoritmos fazem permutações no grafo, para aproveitar as propriedades especiais de um grafo com permutação e, assim um meio mais eficiente para encontrar tais vértices e arestas de corte.

Sendo PI uma função de permutação e * v * um vértice qualquer do grafo:
- se * PI (v) < v * o vértice * v * é chamado de positivo;
- se * PI (v) = v * o vértice * v * é chamado de neutro;
- se * PI (v) > v * o vértice * v * é chamado de negativo.

Todo vértice não neutro pode ser um vértice de corte, então para ser um ponto de articulação, os itens devem ser atendidos:

1. Os nós * i * e * i-1 * são iguais a 1;
2. existe um vértice * u * < * i * e que * PI (u)=i *.

Um outro fato que torna o algoritmo eficiente é a redução do conjunto de arestas que podem ser pontes não simples, com esta redução basta apenas focar nos pontos de articulação.

Além disso, esses algoritmos podem ser estendidos para resolver o problema dos componentes bi-conexos.

No artigo de [@madhumangal1998] é apresentado um algoritmo para encontrar todos os pontos de articulação (vértice de corte) de um grafo de permutação. O algoritmo proposto leva * O(n log n) * tempo e * O(n) * espaço, onde n é o número de vértices.

O algoritmo não é tão trivial para uma explicação mais detalhada, mas a ideia é gerar um gráfico bidimensional (linhas verticais e horizontais) a partir dos vértices e, então os pontos de intersecção das linhas indicam um ponto de articulação, assim o problema é reduzido a encontrar o número * i * da intersecção das linhas * L(i) * e * V(i) *; a \autoref{fig:exemploVertice} mostra como fica este gráfico.

![rotulo da imagem](https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse2.mm.bing.net%2Fth%3Fid%3DOIP.lMlgnWUOBh0lBMWoG0W9pgHaFj%26pid%3DApi&f=1)

No artigo de [@henzinger2015] são expostos algoritmos para determinar os componentes fortemente conectados de 2-arestas e 2-vértices de um grafo direcionado. Uma explicação detalhada não é tão trivial de se fazer, mas de modo geral, a ideia é pegar um conjunto isolado de vértices de conectividade 2. Nos grafos não-dirigidos, os componentes conectados de 2 e 2 vértices podem ser encontrados em tempo linear.

# Considerações finais
Uma das maiores dificuldades é que os artigos encontrados fazem demonstrações para provar a validade dos algoritmos elaborados, o que não é uma tarefa trivial de acompanhar ou explicar no presente artigo.

No tocante sobre o algoritmo, foi observado que ele só identifica arestas e vértices de corte em grafos que possuam ciclos triangulares, ciclos maiores que isso são problemáticos; na \autoref{tab:caso2} as arestas e vértices de corte em destaque são os falso positivo, ou seja, pelo algoritmo são identificado como de corte quando na realidade não são. Portanto, esta solução fica limitada a grafos que possuam ciclos triangulares. Essa conclusão foi constatada observando as árvores que são geradas pelos algoritmos de buscas e como o algoritmo proposto atua nos grafos;  tendo resultado eficaz em grafos que contém ciclos com até três vértices.
*****
@misc{ cormen,
       author = "Oren Patashnik",
       title = "BIBTEXing",
       year = "1988" }
@misc{ italiano2012,
       author = "Oren Patashnik",
       title = "BIBTEXing",
       year = "1988" }
@misc{ ibarra1993,
       author = "Oren Patashnik",
       title = "BIBTEXing",
       year = "1988" }
@misc{ madhumangal1998,
       author = "Oren Patashnik",
       title = "BIBTEXing",
       year = "1988" }
@misc{ henzinger2015,
       author = "Oren Patashnik",
       title = "BIBTEXing",
       year = "1988" }